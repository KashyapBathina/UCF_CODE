/* $Id: spl_lexer_definitions_top.l,v 1.4 2024/10/06 19:16:25 leavens Exp leavens $ */
/* Lexical Analyzer for SPL */

%option header-file = "spl_lexer.h"
%option outfile = "spl_lexer.c"
%option yylineno 
%option bison-bridge 

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <limits.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "spl.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

//global variables
/* The filename of the file being read */
static char *input_filename;

/* Have any errors been noted? */
static bool errors_noted;

//external variables
/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin; //input stream

// We are not using yyunput or input, unused funcs in lexer disabled
#define YY_NO_UNPUT
#define YY_NO_INPUT

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int code) {
    AST t;
    t.token.file_loc = file_location_make(input_filename, yylineno);
    t.token.type_tag = token_ast; //mark token ast
    t.token.code = code; //store token code
    t.token.text = strdup(yytext); //store token text
    yylval = t;
}

//converts identifier to AST node
static void ident2ast(const char *name) {
    AST t;
    assert(input_filename != NULL); //check file is set
    t.ident.file_loc = file_location_make(input_filename, yylineno);
    t.ident.type_tag = ident_ast; //mark identifier AST
    t.ident.name = strdup(name); // store identifier name
    yylval = t;
}

//converts num to AST node
static void number2ast(unsigned int val)
{
    AST t;
    t.number.file_loc = file_location_make(input_filename, yylineno);
    t.number.type_tag = number_ast; // mark num AST
    t.number.text = strdup(yytext); // store num text
    t.number.value = val; // store value
    yylval = t;
}

%}

/*
BELOW recognize specific keywords, returns associated token symbols, create corresponding AST node using tok2ast
recognizes identifiers and returns identsym
rec int converts to unsigned int. if num too large error reported.
rec symbols returns correct token symbols
rule reports error for unrecognized char
*/

 /* you can add actual definitions below, before the %% */



 /* the rules section starts after the %% below */

%%

"%"[^\n]*       { /* Ignore comments starting with % */ }
[ \t\v\f\n\r]+  { /* Ignore space, tab, vertical tab, formfeed, newline, carriage return */ }


"const"         { tok2ast(constsym); return constsym; }
"var"           { tok2ast(varsym); return varsym; }
"proc"          { tok2ast(procsym); return procsym; }
"call"          { tok2ast(callsym); return callsym; }
"begin"         { tok2ast(beginsym); return beginsym; }
"end"           { tok2ast(endsym); return endsym; }
"if"            { tok2ast(ifsym); return ifsym; }
"then"          { tok2ast(thensym); return thensym; }
"else"          { tok2ast(elsesym); return elsesym; }
"while"         { tok2ast(whilesym); return whilesym; }
"do"            { tok2ast(dosym); return dosym; }
"read"          { tok2ast(readsym); return readsym; }
"print"         { tok2ast(printsym); return printsym; }
"divisible"     { tok2ast(divisiblesym); return divisiblesym; }
"by"            { tok2ast(bysym); return bysym; }

"="             { tok2ast(eqsym); return eqsym; }
"=="            { tok2ast(eqeqsym); return eqeqsym; }
"!="            { tok2ast(neqsym); return neqsym; }
"<="            { tok2ast(leqsym); return leqsym; }
">="            { tok2ast(geqsym); return geqsym; }
"<"             { tok2ast(ltsym); return ltsym; }
">"             { tok2ast(gtsym); return gtsym; }
":="            { tok2ast(becomessym); return becomessym; }
"+"             { tok2ast(plussym); return plussym; }
"-"             { tok2ast(minussym); return minussym; }
"*"             { tok2ast(multsym); return multsym; }
"/"             { tok2ast(divsym); return divsym; }

[a-zA-Z][a-zA-Z0-9]*  { ident2ast(yytext); return identsym; }

[0-9]+   {
    unsigned long val = strtoul(yytext, NULL, 10); // getting integer value
    if (val > INT_MAX) { // if integer size exceeds limit . . .
        char err_msg[200]; // create error message buffer
        snprintf(err_msg, sizeof(err_msg), "Number (%s) is too large!", yytext); // format error message
        yyerror(input_filename, err_msg); // call error function
    } 
    number2ast((unsigned int)val);
    return numbersym;
}


";"             { tok2ast(semisym); return semisym; }
"."             { tok2ast(periodsym); return periodsym; }
","             { tok2ast(commasym); return commasym; }
"("             { tok2ast(lparensym); return lparensym; }
")"             { tok2ast(rparensym); return rparensym; }

.               {     
    char err_msg[100];  // Buffer to hold the error message
    snprintf(err_msg, sizeof(err_msg), "invalid character: '%c' ('\\0%o')", yytext[0], yytext[0]); // creating and formatting error message
    yyerror(input_filename, err_msg);  // Pass the formatted message to yyerror
}


%%

















 /* This code goes in the user code section of the spl_lexer.l file,
   following the last %% above. */

// Requires: fname != NULL
// Requires: fname is the name of a readable file
// Initialize the lexer and start it reading
// from the given file name
void lexer_init(char *fname)
{
    errors_noted = false;
    yyin = fopen(fname, "r");
    if (yyin == NULL) {
	bail_with_error("Cannot open %s", fname);
    }
    input_filename = fname;
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", input_filename);
	}
    }
    input_filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return input_filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", input_filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Have any errors been noted by the lexer?
bool lexer_has_errors()
{
    return errors_noted;
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}


/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */

void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);//call lexer
	if (t == YYEOF) { //stop at EOF
	    break;
        }
        lexer_print_token(t, yylineno, yytext); //print tokens
    } while (t != YYEOF);
}
